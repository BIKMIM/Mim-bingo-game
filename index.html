<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>밈주머니 빙고 게임</title>
    <style>
        // 기본 스타일 초기화 */
        * {
            [cite_start]margin: 0; [cite: 1]
            [cite_start]padding: 0; [cite: 2]
            [cite_start]box-sizing: border-box; [cite: 2]
        }

        // 전체 페이지 배경 및 폰트 */
        body {
            [cite_start]font-family: Arial, sans-serif; [cite: 2]
            [cite_start]background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); [cite: 3]
            [cite_start]min-height: 100vh; [cite: 3]
            [cite_start]padding: 20px; [cite: 3]
            [cite_start]display: flex; [cite: 3]
            [cite_start]flex-direction: column; [cite: 3]
            [cite_start]align-items: center; [cite: 3]
            [cite_start]justify-content: center; [cite: 3]
        [cite_start]} [cite: 4]

        // 메인 컨테이너 */
        .container {
            [cite_start]max-width: 1200px; [cite: 4]
            [cite_start]width: 100%; [cite: 5]
            [cite_start]margin: 0 auto; [cite: 5]
            [cite_start]background: white; [cite: 5]
            [cite_start]border-radius: 15px; [cite: 5]
            [cite_start]box-shadow: 0 10px 30px rgba(0,0,0,0.3); [cite: 5]
            [cite_start]overflow: hidden; [cite: 5]
        [cite_start]} [cite: 6]

        // 헤더 */
        .header {
            [cite_start]background: #4a5568; [cite: 6]
            [cite_start]color: white; [cite: 7]
            [cite_start]padding: 20px; [cite: 7]
            [cite_start]text-align: center; [cite: 7]
        }

        // 게임 설정 섹션 */
        .game-setup {
            [cite_start]padding: 30px; [cite: 7]
            [cite_start]border-bottom: 2px solid #e2e8f0; [cite: 8]
        }

        // 방 관련 섹션 */
        .room-section {
            [cite_start]margin-bottom: 30px; [cite: 8]
        }

        // 입력 그룹 (라벨 + 인풋) */
        .input-group {
            [cite_start]margin-bottom: 15px; [cite: 9]
        }

        .input-group label {
            [cite_start]display: block; [cite: 10]
            [cite_start]margin-bottom: 5px; [cite: 11]
            [cite_start]font-weight: bold; [cite: 11]
            [cite_start]color: #4a5568; [cite: 11]
        }

        .input-group input, .input-group select {
            [cite_start]width: 100%; [cite: 11]
            [cite_start]padding: 12px; [cite: 12]
            [cite_start]border: 2px solid #e2e8f0; [cite: 12]
            [cite_start]border-radius: 8px; [cite: 12]
            [cite_start]font-size: 16px; [cite: 12]
        [cite_start]} [cite: 13]

        .input-group input:focus, .input-group select:focus {
            [cite_start]outline: none; [cite: 13]
            [cite_start]border-color: #667eea; [cite: 14]
        }

        // 버튼 그룹 */
        .button-group {
            [cite_start]display: flex; [cite: 14]
            [cite_start]gap: 10px; [cite: 15]
            [cite_start]flex-wrap: wrap; [cite: 15]
        }

        // 일반 버튼 스타일 */
        .btn {
            [cite_start]padding: 12px 24px; [cite: 15]
            [cite_start]border: none; [cite: 16]
            [cite_start]border-radius: 8px; [cite: 16]
            [cite_start]font-size: 16px; [cite: 16]
            [cite_start]cursor: pointer; [cite: 16]
            [cite_start]transition: all 0.3s; [cite: 16]
        [cite_start]} [cite: 17]

        .btn-primary {
            [cite_start]background: #667eea; [cite: 17]
            [cite_start]color: white; [cite: 18]
        }

        .btn-primary:hover {
            [cite_start]background: #5a67d8; [cite: 18]
        [cite_start]} [cite: 19]

        .btn-secondary {
            [cite_start]background: #e2e8f0; [cite: 19]
            [cite_start]color: #4a5568; [cite: 20]
        }

        .btn-secondary:hover {
            [cite_start]background: #cbd5e0; [cite: 20]
        [cite_start]} [cite: 21]

        // 비활성화된 버튼 스타일 */
        .btn:disabled {
            [cite_start]background: #cbd5e0 !important; [cite: 21]
            [cite_start]color: #a0aec0 !important; [cite: 22]
            [cite_start]cursor: not-allowed !important; [cite: 22]
            [cite_start]opacity: 0.6; [cite: 22]
        }

        // 플레이어 목록 섹션 */
        .players-section {
            [cite_start]margin-bottom: 30px; [cite: 22]
        [cite_start]} [cite: 23]

        .players-list {
            [cite_start]background: #f7fafc; [cite: 23]
            [cite_start]border-radius: 8px; [cite: 24]
            [cite_start]padding: 15px; [cite: 24]
            [cite_start]margin-top: 10px; [cite: 24]
        }

        .player-item {
            [cite_start]background: white; [cite: 24]
            [cite_start]padding: 10px 15px; [cite: 25]
            [cite_start]margin: 5px 0; [cite: 25]
            [cite_start]border-radius: 6px; [cite: 25]
            [cite_start]border-left: 4px solid #667eea; [cite: 25]
        [cite_start]} [cite: 26]

        .player-item.host {
            [cite_start]border-left-color: #f56565; [cite: 26]
        [cite_start]} [cite: 27]

        // 미션 섹션 */
        .missions-section {
            [cite_start]margin-bottom: 30px; [cite: 27]
        [cite_start]} [cite: 28]

        .mission-input-area {
            [cite_start]display: flex; [cite: 28]
            [cite_start]gap: 10px; [cite: 29]
            [cite_start]margin-bottom: 15px; [cite: 29]
        }

        .mission-input {
            [cite_start]flex: 1; [cite: 29]
        [cite_start]} [cite: 30]

        .missions-list {
            [cite_start]background: #f7fafc; [cite: 30]
            [cite_start]border-radius: 8px; [cite: 31]
            [cite_start]padding: 15px; [cite: 31]
            [cite_start]max-height: 200px; [cite: 31]
            [cite_start]overflow-y: auto; [cite: 31]
        }

        .mission-item {
            [cite_start]background: white; [cite: 31]
            [cite_start]padding: 10px 15px; [cite: 32]
            [cite_start]margin: 5px 0; [cite: 32]
            [cite_start]border-radius: 6px; [cite: 32]
            [cite_start]display: flex; [cite: 32]
            [cite_start]justify-content: space-between; [cite: 32]
            [cite_start]align-items: center; [cite: 32]
        [cite_start]} [cite: 33]

        .delete-btn {
            [cite_start]background: #e53e3e; [cite: 33]
            [cite_start]color: white; [cite: 34]
            [cite_start]border: none; [cite: 34]
            [cite_start]border-radius: 4px; [cite: 34]
            [cite_start]padding: 5px 10px; [cite: 34]
            [cite_start]cursor: pointer; [cite: 34]
            [cite_start]font-size: 12px; [cite: 34]
        [cite_start]} [cite: 35]

        // 게임 옵션 섹션 */
        .game-options {
            [cite_start]display: flex; [cite: 35]
            [cite_start]gap: 20px; [cite: 36]
            [cite_start]align-items: center; [cite: 36]
            [cite_start]margin-bottom: 30px; [cite: 36]
            [cite_start]flex-wrap: wrap; [cite: 36]
        }

        .radio-group {
            [cite_start]display: flex; [cite: 36]
            [cite_start]gap: 15px; [cite: 37]
        }

        .radio-item {
            [cite_start]display: flex; [cite: 37]
            [cite_start]align-items: center; [cite: 38]
            [cite_start]gap: 5px; [cite: 38]
        }

        // 게임 진행 화면 */
        .game-area {
            [cite_start]padding: 30px; [cite: 38]
            [cite_start]display: none; [cite: 39]
        }

        // 빙고판 */
        .bingo-board {
            [cite_start]display: grid; [cite: 39]
            [cite_start]gap: 10px; [cite: 40]
            [cite_start]max-width: 500px; [cite: 40]
            [cite_start]margin: 0 auto 30px auto; [cite: 40]
            [cite_start]grid-template-columns: repeat(3, 1fr); [cite: 40]
            // 3x3으로 고정 */
        [cite_start]} [cite: 41]

        // 빙고 셀 */
        .bingo-cell {
            [cite_start]aspect-ratio: 1; [cite: 41]
            // 가로세로 비율 1:1 유지 */
            [cite_start]background: #e2e8f0; [cite: 42]
            [cite_start]border: 2px solid #cbd5e0; [cite: 43]
            [cite_start]border-radius: 8px; [cite: 43]
            [cite_start]display: flex; [cite: 43]
            [cite_start]align-items: center; [cite: 43]
            [cite_start]justify-content: center; [cite: 43]
            [cite_start]font-size: 20px; [cite: 43]
            [cite_start]font-weight: bold; [cite: 44]
            [cite_start]cursor: pointer; [cite: 44]
            [cite_start]transition: all 0.3s; [cite: 44]
            [cite_start]color: #4a5568; [cite: 44]
            word-break: break-all; // 긴 텍스트 강제 줄바꿈 (유지) */
            [cite_start]text-align: center; [cite: 44]
            [cite_start]padding: 5px; [cite: 45]
            
            // [핵심 수정 1] 화면 움찔거림(flicker) 방지 */
            [cite_start]overflow: hidden; [cite: 45]
            // [핵심 수정 2] 패딩으로 인한 크기 변경 방지 */
            [cite_start]box-sizing: border-box; [cite: 46]
        [cite_start]} [cite: 47]

        .bingo-cell:hover {
            [cite_start]background: #cbd5e0; [cite: 47]
        [cite_start]} [cite: 48]

        // Flipped (체크됨) 및 Failed (실패) 상태 */
        .bingo-cell.flipped,
        .bingo-cell.failed {
            [cite_start]color: white; [cite: 48]
            // [핵심 수정 3] 동적/반응형 폰트 크기 적용 */
            // 화면 너비에 따라 폰트 크기를 8px ~ 13px 사이에서 유연하게 조절합니다.
            [cite_start]*/ [cite: 50]
            [cite_start]font-size: clamp(8px, 3vw, 13px); [cite: 51]
            // [핵심 수정 4] 줄 간격을 조절하여 가독성 확보 */
            [cite_start]line-height: 1.15; [cite: 52]
        }

        // Flipped (체크됨) 상태 고유 스타일 */
        .bingo-cell.flipped {
            [cite_start]background: #667eea; [cite: 52]
        [cite_start]} [cite: 53]

        // Failed (실패) 상태 고유 스타일 */
        .bingo-cell.failed {
            [cite_start]background: #f56565; [cite: 53]
            [cite_start]text-decoration: line-through; [cite: 54]
            [cite_start]opacity: 0.7; [cite: 54]
        }

        // 게임 상태 표시 */
        .game-status {
            [cite_start]text-align: center; [cite: 54]
            [cite_start]margin-bottom: 20px; [cite: 55]
        }

        .status-text {
            [cite_start]font-size: 18px; [cite: 55]
            [cite_start]color: #4a5568; [cite: 56]
            [cite_start]margin-bottom: 10px; [cite: 56]
        }

        .room-code-display {
            [cite_start]background: #667eea; [cite: 56]
            [cite_start]color: white; [cite: 57]
            [cite_start]padding: 10px 20px; [cite: 57]
            [cite_start]border-radius: 8px; [cite: 57]
            [cite_start]font-size: 20px; [cite: 57]
            [cite_start]font-weight: bold; [cite: 58]
            [cite_start]display: inline-block; [cite: 58]
        }

        // 숨김 처리 */
        .hidden {
            [cite_start]display: none; [cite: 59]
        }

        // 로딩 메시지 */
        .loading {
            [cite_start]text-align: center; [cite: 59]
            [cite_start]color: #667eea; [cite: 60]
            [cite_start]font-style: italic; [cite: 60]
        }

        // 오류 메시지 */
        .error {
            [cite_start]background: #fed7d7; [cite: 60]
            [cite_start]color: #c53030; [cite: 61]
            [cite_start]padding: 10px; [cite: 61]
            [cite_start]border-radius: 6px; [cite: 61]
            [cite_start]margin: 10px 0; [cite: 61]
        }

        // 성공 메시지 */
        .success {
            [cite_start]background: #c6f6d5; [cite: 61]
            [cite_start]color: #2f855a; [cite: 62]
            [cite_start]padding: 10px; [cite: 62]
            [cite_start]border-radius: 6px; [cite: 62]
            [cite_start]margin: 10px 0; [cite: 62]
        }

        // Bingo Button 스타일 */
        #bingo-button {
            [cite_start]background-color: #4CAF50; [cite: 63]
            [cite_start]color: white; [cite: 63]
            [cite_start]padding: 15px 30px; [cite: 63]
            [cite_start]font-size: 24px; [cite: 64]
            [cite_start]font-weight: bold; [cite: 64]
            [cite_start]border: none; [cite: 64]
            [cite_start]border-radius: 10px; [cite: 64]
            [cite_start]cursor: pointer; [cite: 64]
            [cite_start]transition: background-color 0.3s ease, transform 0.1s ease; [cite: 64]
            [cite_start]margin-top: 20px; [cite: 64]
            [cite_start]display: block; [cite: 65]
            // 항상 보이도록 설정 */
            [cite_start]width: 100%; [cite: 65]
            [cite_start]max-width: 300px; [cite: 66]
            [cite_start]box-sizing: border-box; [cite: 66]
        }
        
        #bingo-button:hover:not(:disabled) {
            [cite_start]background-color: #45a049; [cite: 68]
            [cite_start]transform: scale(1.05); [cite: 68]
        }
        
        #bingo-button:disabled {
            [cite_start]background-color: #ccc; [cite: 70]
            [cite_start]cursor: not-allowed; [cite: 70]
            [cite_start]opacity: 0.7; [cite: 70]
        }

        // 버튼 컨테이너 */
        .game-buttons {
            [cite_start]display: flex; [cite: 71]
            [cite_start]flex-direction: column; [cite: 71]
            [cite_start]align-items: center; [cite: 71]
            [cite_start]gap: 10px; [cite: 71]
            box-sizing: border-box; // 추가: 패딩 포함 너비 계산 */
        }

        // 비밀번호 입력 팝업용 오버레이 */
        .password-overlay {
            [cite_start]position: fixed; [cite: 71]
            [cite_start]top: 0; [cite: 72]
            [cite_start]left: 0; [cite: 72]
            [cite_start]width: 100%; [cite: 72]
            [cite_start]height: 100%; [cite: 72]
            [cite_start]background-color: rgba(0, 0, 0, 0.7); [cite: 72]
            [cite_start]display: flex; [cite: 72]
            [cite_start]justify-content: center; [cite: 73]
            [cite_start]align-items: center; [cite: 73]
            z-index: 2000; // 승리 오버레이보다 높게 설정 */
        }

        .password-prompt {
            [cite_start]background-color: white; [cite: 73]
            [cite_start]padding: 30px; [cite: 74]
            [cite_start]border-radius: 10px; [cite: 74]
            [cite_start]box-shadow: 0 5px 15px rgba(0,0,0,0.3); [cite: 74]
            [cite_start]text-align: center; [cite: 74]
            [cite_start]width: 90%; [cite: 74]
            [cite_start]max-width: 400px; [cite: 75]
        [cite_start]} [cite: 75]

        .password-prompt h3 {
            [cite_start]margin-bottom: 20px; [cite: 76]
            [cite_start]color: #4a5568; [cite: 76]
        }

        .password-prompt input {
            [cite_start]width: calc(100% - 24px); [cite: 76]
            // 패딩 고려 */
            [cite_start]padding: 12px; [cite: 77]
            [cite_start]margin-bottom: 15px; [cite: 78]
            [cite_start]border: 1px solid #e2e8f0; [cite: 78]
            [cite_start]border-radius: 5px; [cite: 78]
            [cite_start]font-size: 18px; [cite: 78]
        }

        .password-prompt button {
            [cite_start]padding: 10px 20px; [cite: 79]
            [cite_start]background-color: #667eea; [cite: 79]
            [cite_start]color: white; [cite: 79]
            [cite_start]border: none; [cite: 79]
            [cite_start]border-radius: 5px; [cite: 79]
            [cite_start]cursor: pointer; [cite: 79]
            [cite_start]font-size: 16px; [cite: 80]
            [cite_start]margin: 0 5px; [cite: 80]
        [cite_start]} [cite: 80]
        .password-prompt button:hover {
            [cite_start]background-color: #5a67d8; [cite: 81]
        [cite_start]} [cite: 81]

        // 승리 메시지 오버레이 */
        .winner-overlay {
            [cite_start]position: fixed; [cite: 81]
            [cite_start]top: 0; [cite: 82]
            [cite_start]left: 0; [cite: 82]
            [cite_start]width: 100%; [cite: 82]
            [cite_start]height: 100%; [cite: 82]
            [cite_start]background-color: rgba(0, 0, 0, 0.7); [cite: 83]
            // 반투명 검정 배경 */
            [cite_start]display: flex; [cite: 83]
            [cite_start]justify-content: center; [cite: 84]
            [cite_start]align-items: center; [cite: 84]
            [cite_start]z-index: 1000; [cite: 84]
            [cite_start]animation: fadeIn 0.5s ease-out; [cite: 84]
        }

        .winner-message {
            [cite_start]background-color: white; [cite: 84]
            // 팝업 배경색 흰색 */
            [cite_start]color: #4a5568; [cite: 85]
            // 기본 텍스트 색상 */
            [cite_start]font-size: 3em; [cite: 86]
            [cite_start]font-weight: bold; [cite: 87]
            [cite_start]text-align: center; [cite: 87]
            [cite_start]padding: 40px; [cite: 87]
            [cite_start]border-radius: 20px; [cite: 87]
            [cite_start]box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5); [cite: 88]
            [cite_start]animation: zoomIn 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; [cite: 88]
            [cite_start]position: relative; [cite: 88]
            [cite_start]overflow: hidden; [cite: 88]
            [cite_start]display: flex; [cite: 88]
            [cite_start]flex-direction: column; [cite: 89]
            [cite_start]align-items: center; [cite: 89]
            [cite_start]gap: 15px; [cite: 89]
        }

        // 텍스트에만 그라데이션 적용 */
        .gradient-text {
            [cite_start]background: linear-gradient(45deg, #f3ec78, #af4261); [cite: 90]
            [cite_start]-webkit-background-clip: text; [cite: 90]
            [cite_start]-webkit-text-fill-color: transparent; [cite: 90]
            [cite_start]background-clip: text; [cite: 90]
            color: transparent; // Fallback for browsers not supporting text-fill-color */
        }

        .winner-message .emoji {
            [cite_start]font-size: 1.5em; [cite: 91]
            [cite_start]-webkit-text-fill-color: initial; [cite: 91]
            [cite_start]background: none; [cite: 91]
        }

        .winner-message .winner-text {
            [cite_start]font-size: 1em; [cite: 92]
            [cite_start]line-height: 1.3; [cite: 92]
        }

        .winner-message .btn {
            [cite_start]background-color: #667eea; [cite: 93]
            [cite_start]color: white; [cite: 93]
            [cite_start]border: none; [cite: 93]
            [cite_start]padding: 10px 20px; [cite: 93]
            [cite_start]border-radius: 8px; [cite: 93]
            [cite_start]cursor: pointer; [cite: 94]
            [cite_start]font-size: 0.6em; [cite: 94]
            [cite_start]transition: background-color 0.3s; [cite: 94]
        }

        .winner-message .btn:hover {
            [cite_start]background-color: #5a67d8; [cite: 95]
        [cite_start]} [cite: 95]

        // 애니메이션 키프레임 */
        @keyframes fadeIn {
            [cite_start]from { opacity: 0; [cite: 96] }
            [cite_start]to { opacity: 1; [cite: 97] }
        }

        @keyframes zoomIn {
            [cite_start]from { transform: scale(0.5); [cite: 98] opacity: 0; }
            [cite_start]to { transform: scale(1); opacity: 1; [cite: 99] }
        }

        // 반응형 디자인 */
        @media (max-width: 768px) {
            .container {
                [cite_start]margin: 10px; [cite: 100]
            }
            
            .button-group {
                [cite_start]flex-direction: column; [cite: 101]
            }
            
            .game-options {
                [cite_start]flex-direction: column; [cite: 102]
                [cite_start]align-items: flex-start; [cite: 102]
            }

            .winner-message {
                [cite_start]font-size: 2em; [cite: 103]
                [cite_start]padding: 20px; [cite: 103]
            }
        }

        // 새로운 flex 컨테이너를 위한 스타일 */
        .create-room-controls {
            [cite_start]display: flex; [cite: 104]
            [cite_start]flex-wrap: wrap; [cite: 104]
            align-items: flex-end; // 버튼과 드롭다운이 바닥선에 정렬되도록 */
            [cite_start]gap: 10px; [cite: 105]
            [cite_start]margin-top: 15px; [cite: 105]
        }

        .create-room-controls .input-group {
            [cite_start]margin-bottom: 0; [cite: 106]
            // 이 그룹 내부의 input-group은 마진 제거 */
        }

        // max-players select box의 너비를 조정하여 버튼과 잘 어울리게 */
        .create-room-controls #max-players-create {
            [cite_start]width: auto; [cite: 107]
            // 자동 너비 */
            [cite_start]min-width: 100px; [cite: 108]
            // 최소 너비 설정 */
            [cite_start]flex-grow: 1; [cite: 109]
            // 남은 공간을 채우도록 성장 */
        }

        // '새 방 만들기' 버튼 크기 키우기 */
        .create-room-controls #create-room-btn {
            [cite_start]padding: 15px 30px; [cite: 110]
            // 패딩을 늘려 크기 키움 */
            [cite_start]font-size: 18px; [cite: 111]
            // 글자 크기 키움 */
            [cite_start]flex-shrink: 0; [cite: 112]
            // 줄어들지 않도록 */
        }

        // 방 입장하기 버튼 숨김을 위한 클래스 추가 (초대링크 시) */
        .hidden-by-url-param {
            [cite_start]display: none !important; [cite: 113]
            // 우선순위 높임 */
        }

        // 최대 플레이어 수 드롭다운의 label과 select가 가로로 나란히 오도록 */
        .input-group.inline-label {
            [cite_start]display: flex; [cite: 114]
            [cite_start]align-items: center; [cite: 114]
            [cite_start]gap: 10px; [cite: 114]
            [cite_start]flex-grow: 1; [cite: 114]
        }

        .input-group.inline-label label {
            [cite_start]margin-bottom: 0; [cite: 115]
            flex-shrink: 0; // 라벨이 줄어들지 않도록 */
        [cite_start]} [cite: 115]
        .input-group.inline-label select {
            [cite_start]width: auto; [cite: 116]
            // select가 자동으로 너비 조정 */
            [cite_start]flex-grow: 1; [cite: 117]
            // 남은 공간 채우기 */
        [cite_start]} [cite: 117]

        // 로딩 인디케이터 추가 */
        .loading-indicator {
            [cite_start]display: inline-block; [cite: 118]
            [cite_start]width: 16px; [cite: 118]
            [cite_start]height: 16px; [cite: 118]
            [cite_start]border: 2px solid #f3f3f3; [cite: 118]
            [cite_start]border-top: 2px solid #667eea; [cite: 119]
            [cite_start]border-radius: 50%; [cite: 119]
            [cite_start]animation: spin 1s linear infinite; [cite: 119]
            [cite_start]margin-right: 8px; [cite: 119]
        }

        @keyframes spin {
            [cite_start]0% { transform: rotate(0deg); [cite: 120] }
            [cite_start]100% { transform: rotate(360deg); [cite: 121] }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 밈주머니 빙고 게임!</h1>
            <p>밈주머니와 함께 즐기는 쐐기 빙고!</p>
            <div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">
                v4.982 - 턴 삭제
            [cite_start]</div> [cite: 122]
        </div>

        <div id="game-setup" class="game-setup">
            <div class="room-section">
                <h2>🏠 방 설정</h2>
                <div class="input-group">
                    <label for="player-name">플레이어 이름</label>
                    [cite_start]<input type="text" id="player-name" placeholder="당신의 닉네임을 입력하세요" maxlength="10"> [cite: 123]
                </div>
                
                <div class="create-room-controls">
                    <div class="input-group inline-label" id="max-players-create-group">
                        [cite_start]<label for="max-players-create">최대 플레이어 수:</label> [cite: 124]
                        <select id="max-players-create">
                            <option value="2">2명</option>
                            [cite_start]<option value="3">3명</option> [cite: 125]
                            <option value="4">4명</option>
                            <option value="5">5명</option>
                            <option value="6">6명</option>
                            [cite_start]<option value="7">7명</option> [cite: 126]
                            <option value="8">8명</option>
                            <option value="9">9명</option>
                            [cite_start]<option value="10">10명</option> [cite: 127]
                            <option value="11">11명</option>
                            <option value="12">12명</option>
                        </select>
                    [cite_start]</div> [cite: 128]
                    <button class="btn btn-primary" id="create-room-btn" onclick="createRoom()">새 방 만들기</button>
                </div>

                <div class="button-group" id="main-action-buttons" style="margin-top: 15px;">
                    <button class="btn btn-secondary" id="show-join-room-btn" onclick="showJoinRoom()">방 입장하기</button>
                [cite_start]</div> [cite: 129]

                <div id="join-room-section" class="hidden" style="margin-top: 15px;">
                    <div class="input-group">
                        <label for="room-code">방 코드</label>
                        [cite_start]<input type="text" id="room-code" placeholder="방 코드를 입력하세요" maxlength="8"> [cite: 130]
                    </div>
                    <button class="btn btn-primary" onclick="joinRoom()">방 입장</button>
                    [cite_start]<p id="auto-join-hint" class="hidden" style="color: #667eea; [cite: 131] font-size: 14px; margin-top: 10px;">
                        
                    </p>
                </div>

                <div id="status-message"></div>
                
                [cite_start]<div id="share-section" class="hidden" style="margin-top: 20px;"> [cite: 132]
                    [cite_start]<div style="background: #f7fafc; [cite: 133] padding: 15px; border-radius: 8px; border: 2px solid #667eea;">
                        [cite_start]<h4 style="color: #4a5568; [cite: 134] margin-bottom: 10px;">🔗 친구 초대 링크</h4>
                        [cite_start]<div style="display: flex; [cite: 135] gap: 10px; align-items: center;">
                            [cite_start]<input type="text" id="share-link" readonly style="flex: 1; [cite: 136] [cite_start]background: white; border: 1px solid #e2e8f0; padding: 8px; border-radius: 4px; [cite: 137] font-size: 14px;">
                            <button class="btn btn-primary" onclick="copyShareLink()" style="padding: 8px 16px;">복사</button>
                        </div>
                        [cite_start]<p style="color: #718096; [cite: 138] font-size: 12px; margin-top: 8px;">
                            이 링크를 친구들에게 보내면 바로 방에 입장할 수 있어요!
                        </p>
                    </div>
                </div>
            [cite_start]</div> [cite: 139]

            <div class="players-section">
                <h3>👥 참가자 목록</h3>
                <div class="players-list" id="players-list">
                    <div class="loading">방에 입장하면 참가자가 표시됩니다</div>
                [cite_start]</div> [cite: 140]
            </div>

            <div class="missions-section">
                <h3>📝 미션 텍스트</h3>
                <div class="mission-input-area">
                    <input type="text" class="mission-input" id="mission-input" placeholder="미션 내용을 입력하세요" maxlength="200">
                    [cite_start]<button class="btn btn-primary" id="add-mission-btn" onclick="addMission()">추가</button> [cite: 141]
                </div>
                <div class="button-group" style="margin-bottom: 15px;">
                    <button class="btn btn-secondary" onclick="saveMissions()">미션 저장</button>
                    <button class="btn btn-secondary" onclick="loadMissions()">미션 불러오기 (기본값)</button>
                [cite_start]</div> [cite: 142]
                <div class="missions-list" id="missions-list">
                    </div>
                [cite_start]<div id="current-mission-count" style="text-align: center; [cite: 143] margin-top: 10px; font-size: 14px; color: #718096;">
                    현재 등록된 미션: 0개
                </div>
            </div>

            <div class="game-options" id="game-options-section">
                <div>
                    [cite_start]<label><strong>빙고판 크기:</strong></label> [cite: 144]
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" name="board-size" value="3" id="size-3" checked disabled> <label for="size-3">3x3</label>
                        [cite_start]</div> [cite: 145]
                    </div>
                </div>
                <div>
                    <label><strong>승리 조건:</strong></label>
                    [cite_start]<div class="radio-group"> [cite: 146]
                        <div class="radio-item">
                            <input type="radio" name="win-condition" value="1" id="win-1" checked>
                            <label for="win-1">1줄 빙고</label>
                        [cite_start]</div> [cite: 147]
                        <div class="radio-item">
                            <input type="radio" name="win-condition" value="2" id="win-2">
                            [cite_start]<label for="win-2">2줄 빙고</label> [cite: 148]
                        </div>
                        <div class="radio-item">
                            <input type="radio" name="win-condition" value="3" id="win-3">
                            [cite_start]<label for="win-3">3줄 빙고</label> [cite: 149]
                        </div>
                    </div>
                </div>
                
                </div>

            <div style="text-align: center;">
                [cite_start]<button class="btn btn-primary" id="start-game-btn" onclick="startGame()" style="font-size: 18px; [cite: 152] padding: 15px 30px;">
                    🎮 게임 시작!
                [cite_start]</button> [cite: 153]
            </div>
        </div>

        <div id="game-area" class="game-area">
            <div class="game-status">
                [cite_start]<div class="status-text">방 코드: <span class="room-code-display" id="current-room-code">ABC123">ABC123</span></div> [cite: 154]
                <div class="status-text">선택 된 숫자: <strong id="flipped-numbers-count">0</strong></div> </div>

            <div class="bingo-board" id="bingo-board">
                </div>
            
            [cite_start]<div class="game-buttons"> [cite: 155]
                <button id="bingo-button" class="btn btn-primary" onclick="claimBingo()" disabled>
                    [cite_start]🎉 빙고! [cite: 156]
                </button>
                </div>

            <div style="text-align: center; margin-top: 20px;">
                [cite_start]<button class="btn btn-secondary" onclick="backToSetup()">게임 설정으로 돌아가기</button> [cite: 157]
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <script>
        // Firebase 설정
        const firebaseConfig = {
            apiKey: "AIzaSyAqHKfUCypD_Jk7mXgH5u-O1XS7Dje4DZ8",
            authDomain: "mim-bingo-game.firebaseapp.com",
            [cite_start]databaseURL: "https://mim-bingo-game-default-rtdb.asia-southeast1.firebasedatabase.app", [cite: 158]
            [cite_start]projectId: "mim-bingo-game", [cite: 158]
            [cite_start]storageBucket: "mim-bingo-game.firebasestorage.app", [cite: 158]
            [cite_start]messagingSenderId: "436254307510", [cite: 158]
            [cite_start]appId: "1:436254307510:web:23ad7c9a0d10d8ad26217" [cite: 158]
        [cite_start]}; [cite: 159]
        // Firebase 초기화
        [cite_start]firebase.initializeApp(firebaseConfig); [cite: 159]
        [cite_start]const database = firebase.database(); [cite: 159]
        [cite_start]const auth = firebase.auth(); [cite: 160]

        // 기본 미션 목록 (localStorage에 저장된 미션이 없을 경우 사용)
        const defaultMissions = [
            "미션1",
            "미션2",
            "미션3",
            "미션4",
            "미션5",
            "미션6",
            [cite_start]"미션7", [cite: 161]
            [cite_start]"미션8", [cite: 161]
            [cite_start]"미션9", [cite: 161]
            [cite_start]"미션10" [cite: 161]
        [cite_start]]; [cite: 162]

        // 게임 상태 변수들
        let gameState = {
            [cite_start]isHost: false, [cite: 162]
            [cite_start]roomCode: '', [cite: 162]
            [cite_start]playerName: '', [cite: 162]
            [cite_start]playerUID: null, [cite: 163]
            [cite_start]players: {}, [cite: 163]
            [cite_start]missions: [], [cite: 163]
            [cite_start]winCondition: 1, [cite: 163]
            [cite_start]boardSize: 3, [cite: 163]
            [cite_start]maxPlayers: 2, [cite: 163]
            [cite_start]gameStarted: false, [cite: 163]
            [cite_start]bingoBoard: [], [cite: 163]
            currentTurn: 0, // 턴 개념은 유지하지만, 턴 제한 없이 클릭 가능
            [cite_start]playerList: [], [cite: 164]
            [cite_start]roomRef: null, [cite: 164]
            [cite_start]missionMap: {}, [cite: 164]
            [cite_start]canClaimBingo: false, [cite: 164]
            [cite_start]flippedNumbers: [], [cite: 165]
            hasMadeMoveInTurn: false, // 이 변수는 더 이상 사용되지 않지만, 기존 로직에서 제거되지 않도록 유지
            [cite_start]isAuthReady: false [cite: 165]
        [cite_start]}; [cite: 165]

        // 호스트 전용 비밀번호
        [cite_start]const HOST_PASSWORD = "0804"; [cite: 165]

        // UI 버튼 상태 업데이트 함수
        function updateButtonStates() {
            [cite_start]const createRoomBtn = document.getElementById('create-room-btn'); [cite: 166]
            [cite_start]const joinRoomBtn = document.querySelector('button[onclick="joinRoom()"]'); [cite: 167]
            
            if (gameState.isAuthReady) {
                // 인증 완료 시 버튼 활성화
                [cite_start]createRoomBtn.disabled = false; [cite: 167]
                [cite_start]createRoomBtn.innerHTML = '새 방 만들기'; [cite: 168]
                if (joinRoomBtn) {
                    [cite_start]joinRoomBtn.disabled = false; [cite: 168]
                    [cite_start]joinRoomBtn.innerHTML = '방 입장'; [cite: 169]
                }
            } else {
                // 인증 대기 시 버튼 비활성화 및 로딩 표시
                [cite_start]createRoomBtn.disabled = true; [cite: 169]
                [cite_start]createRoomBtn.innerHTML = '<span class="loading-indicator"></span>로그인 중...'; [cite: 170]
                if (joinRoomBtn) {
                    [cite_start]joinRoomBtn.disabled = true; [cite: 170]
                    [cite_start]joinRoomBtn.innerHTML = '<span class="loading-indicator"></span>로그인 중...'; [cite: 171]
                }
            }
        }

        // 상태 메시지 표시
        function showMessage(message, type = 'info') {
            [cite_start]const statusDiv = document.getElementById('status-message'); [cite: 171]
            [cite_start]statusDiv.innerHTML = `<div class="${type}">${message}</div>`; [cite: 172]
            [cite_start]statusDiv.style.opacity = '1'; [cite: 172]
            [cite_start]statusDiv.style.transition = 'opacity 0.5s ease-out'; [cite: 173]
            setTimeout(() => {
                [cite_start]statusDiv.style.opacity = '0'; [cite: 173]
                setTimeout(() => {
                    [cite_start]statusDiv.innerHTML = ''; [cite: 173]
                [cite_start]}, 500); [cite: 173]
            [cite_start]}, 3000); [cite: 174]
        }

        // --- 익명 로그인 처리 로직 ---
        auth.onAuthStateChanged(user => {
            if (user) {
                console.log("Firebase Anonymous User UID:", user.uid);
                gameState.playerUID = user.uid;
                gameState.isAuthReady = true;
                [cite_start]updateButtonStates(); [cite: 175]
                
                // URL 파라미터 체크 (자동 입장)
                checkURLParams();
            } else {
                [cite_start]console.log("No Firebase user logged in. Signing in anonymously..."); [cite: 176]
                [cite_start]gameState.isAuthReady = false; [cite: 176]
                [cite_start]updateButtonStates(); [cite: 176]
                
                auth.signInAnonymously()
                    .then(() => {
                        // 성공적으로 익명 로그인되었으므로, onAuthStateChanged 콜백이 다시 호출될 것입니다.
                    [cite_start]}) [cite: 177]
                    .catch((error) => {
                        [cite_start]console.error("Error signing in anonymously:", error); [cite: 178]
                        [cite_start]showMessage('게임에 접속할 수 없습니다. 페이지를 새로고침해주세요.', 'error'); [cite: 179]
                        [cite_start]gameState.isAuthReady = false; [cite: 179]
                        [cite_start]updateButtonStates(); [cite: 179]
                    });
            }
        [cite_start]}); [cite: 180]

        // 비밀번호 입력 팝업 생성 함수
        function createPasswordPrompt() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'password-overlay';

                const promptBox = document.createElement('div');
                [cite_start]promptBox.className = 'password-prompt'; [cite: 181]
                promptBox.innerHTML = `
                    <h3>방장이 되려면 비밀번호를 입력하세요.</h3>
                    <input type="password" id="host-password-input" placeholder="비밀번호">
                    <button id="password-submit-btn">확인</button>
                    [cite_start]<button id="password-cancel-btn">취소</button> [cite: 182]
                `;
                [cite_start]overlay.appendChild(promptBox); [cite: 182]
                [cite_start]document.body.appendChild(overlay); [cite: 182]

                [cite_start]const passwordInput = document.getElementById('host-password-input'); [cite: 183]
                [cite_start]const submitBtn = document.getElementById('password-submit-btn'); [cite: 184]
                [cite_start]const cancelBtn = document.getElementById('password-cancel-btn'); [cite: 184]
                const cleanup = () => {
                    [cite_start]document.body.removeChild(overlay); [cite: 184]
                    [cite_start]submitBtn.removeEventListener('click', handleSubmit); [cite: 185]
                    [cite_start]cancelBtn.removeEventListener('click', handleCancel); [cite: 185]
                    [cite_start]passwordInput.removeEventListener('keypress', handleKeyPress); [cite: 185]
                };

                const handleSubmit = () => {
                    [cite_start]const password = passwordInput.value; [cite: 186]
                    [cite_start]cleanup(); [cite: 186]
                    [cite_start]resolve(password); [cite: 186]
                };

                const handleCancel = () => {
                    [cite_start]cleanup(); [cite: 187]
                    [cite_start]resolve(null); [cite: 187]
                };

                const handleKeyPress = (e) => {
                    if (e.key === 'Enter') {
                        [cite_start]handleSubmit(); [cite: 188]
                    }
                };

                [cite_start]submitBtn.addEventListener('click', handleSubmit); [cite: 189]
                [cite_start]cancelBtn.addEventListener('click', handleCancel); [cite: 189]
                [cite_start]passwordInput.addEventListener('keypress', handleKeyPress); [cite: 189]
                [cite_start]passwordInput.focus(); [cite: 189]
            });
        }

        // 방 생성 (호스트 비밀번호 필요)
        async function createRoom() {
            [cite_start]const playerNameInput = document.getElementById('player-name').value.trim(); [cite: 190]
            if (!playerNameInput) {
                [cite_start]showMessage('플레이어 이름을 입력해주세요!', 'error'); [cite: 191]
                return;
            }

            // 인증 상태 확인
            if (!gameState.isAuthReady || !gameState.playerUID) {
                [cite_start]showMessage('아직 로그인 중입니다. 잠시 후 다시 시도해주세요.', 'error'); [cite: 192]
                return;
            }

            [cite_start]const password = await createPasswordPrompt(); [cite: 193]
            if (password !== HOST_PASSWORD) {
                [cite_start]showMessage('비밀번호가 올바르지 않거나 취소되었습니다!', 'error'); [cite: 194]
                return;
            }

            try {
                [cite_start]gameState.isHost = true; [cite: 195]
                [cite_start]gameState.playerName = playerNameInput; [cite: 195]
                [cite_start]gameState.roomCode = generateRoomCode(); [cite: 195]
                [cite_start]gameState.maxPlayers = parseInt(document.getElementById('max-players-create').value); [cite: 195]
                
                [cite_start]gameState.roomRef = database.ref('rooms/' + gameState.roomCode); [cite: 196]
                await gameState.roomRef.set({
                    host: gameState.playerUID,
                    players: {
                        [gameState.playerUID]: {
                            name: gameState.playerName,
                            [cite_start]isHost: true, [cite: 197]
                            [cite_start]joinedAt: Date.now(), [cite: 197]
                            [cite_start]boardState: {} [cite: 198]
                        }
                    },
                    missions: gameState.missions,
                    gameStarted: false,
                    winCondition: 1,
                    [cite_start]boardSize: gameState.boardSize, [cite: 199]
                    [cite_start]maxPlayers: gameState.maxPlayers, [cite: 199]
                    [cite_start]createdAt: Date.now(), [cite: 199]
                    [cite_start]flippedNumbers: {}, [cite: 199]
                    currentTurn: 0, // 선공 선택 로직 제거에 따라 0으로 고정
                    [cite_start]winner: null, [cite: 200]
                    [cite_start]gameEnded: false, [cite: 200]
                    [cite_start]missionMap: {}, [cite: 200]
                    [cite_start]bingoClaimed: null, [cite: 201]
                    [cite_start]playerOrderUids: [gameState.playerUID] [cite: 201]
                });

                [cite_start]setupRoomListeners(); [cite: 202]
                [cite_start]const shareLink = `${window.location.origin}${window.location.pathname}?room=${gameState.roomCode}`; [cite: 202]
                [cite_start]document.getElementById('share-link').value = shareLink; [cite: 202]
                [cite_start]document.getElementById('share-section').classList.remove('hidden'); [cite: 202]
                
                [cite_start]showMessage(`방이 생성되었습니다! 방 코드: ${gameState.roomCode}`, 'success'); [cite: 202]
            } catch (error) {
                [cite_start]showMessage('방 생성에 실패했습니다: ' + error.message, 'error'); [cite: 203]
                [cite_start]console.error('방 생성 오류:', error); [cite: 204]
            }
        }

        // 방 입장 UI 표시
        function showJoinRoom() {
            [cite_start]document.getElementById('join-room-section').classList.remove('hidden'); [cite: 204]
            [cite_start]document.getElementById('create-room-btn').classList.add('hidden-by-url-param'); [cite: 205]
            [cite_start]document.getElementById('max-players-create-group').classList.add('hidden-by-url-param'); [cite: 205]
            [cite_start]document.getElementById('main-action-buttons').classList.add('hidden-by-url-param'); [cite: 205]
        }

        // 방 입장
        async function joinRoom(prefilledRoomCode = null) {
            [cite_start]const playerNameInput = document.getElementById('player-name').value.trim(); [cite: 206]
            [cite_start]const roomCode = prefilledRoomCode || document.getElementById('room-code').value.trim().toUpperCase(); [cite: 206]
            
            if (!playerNameInput) {
                [cite_start]showMessage('플레이어 이름을 입력해주세요!', 'error'); [cite: 207]
                return;
            }
            
            if (!roomCode) {
                [cite_start]showMessage('방 코드를 입력해주세요!', 'error'); [cite: 208]
                return;
            }

            // 인증 상태 확인
            if (!gameState.isAuthReady || !gameState.playerUID) {
                [cite_start]showMessage('아직 로그인 중입니다. 잠시 후 다시 시도해주세요.', 'error'); [cite: 209]
                return;
            }

            try {
                [cite_start]gameState.isHost = false; [cite: 210]
                [cite_start]gameState.playerName = playerNameInput; [cite: 210]
                [cite_start]gameState.roomCode = roomCode; [cite: 210]
                [cite_start]gameState.roomRef = database.ref('rooms/' + roomCode); [cite: 210]

                [cite_start]const snapshot = await gameState.roomRef.once('value'); [cite: 211]
                if (!snapshot.exists()) {
                    [cite_start]showMessage('존재하지 않는 방 코드입니다!', 'error'); [cite: 212]
                    return;
                }

                [cite_start]const roomData = snapshot.val(); [cite: 213]
                if (roomData.gameStarted) {
                    [cite_start]showMessage('이미 시작된 게임입니다!', 'error'); [cite: 214]
                    return;
                }
                
                [cite_start]const currentPlayersCount = Object.keys(roomData.players || {}).length; [cite: 215]
                if (roomData.maxPlayers && currentPlayersCount >= roomData.maxPlayers) {
                    [cite_start]showMessage(`이 방은 최대 ${roomData.maxPlayers}명까지 참여 가능합니다. 현재 인원: ${currentPlayersCount}명`, 'error'); [cite: 216]
                    return;
                }

                if (roomData.players && roomData.players[gameState.playerUID]) {
                     [cite_start]showMessage('이미 이 방에 접속 중입니다.', 'info'); [cite: 217]
                     [cite_start]setupRoomListeners(); [cite: 217]
                     return;
                }

                [cite_start]const existingPlayerNames = Object.values(roomData.players || {}).map(p => p.name); [cite: 218]
                if (existingPlayerNames.includes(playerNameInput)) {
                    [cite_start]showMessage('이미 사용 중인 이름입니다. 다른 이름을 선택해주세요!', 'error'); [cite: 219]
                    return;
                }

                await gameState.roomRef.child('players').child(gameState.playerUID).set({
                    name: gameState.playerName,
                    isHost: false,
                    joinedAt: Date.now(),
                    [cite_start]boardState: {} [cite: 220]
                [cite_start]}); [cite: 221]
                await gameState.roomRef.child('playerOrderUids').transaction((currentUids) => {
                    const uids = currentUids || [];
                    if (!uids.includes(gameState.playerUID)) {
                        uids.push(gameState.playerUID);
                    }
                    [cite_start]return uids; [cite: 222]
                [cite_start]}); [cite: 223]
                gameState.boardSize = roomData.boardSize || [cite_start]3; [cite: 223]
                gameState.maxPlayers = roomData.maxPlayers || [cite_start]2; [cite: 223]
                
                [cite_start]setupRoomListeners(); [cite: 224]
                [cite_start]showMessage(`방에 입장했습니다! 방 코드: ${roomCode}`, 'success'); [cite: 224]
            } catch (error) {
                [cite_start]showMessage('방 입장에 실패했습니다: ' + error.message, 'error'); [cite: 225]
                [cite_start]console.error('방 입장 오류:', error); [cite: 225]
            }
        }

        // 방 데이터 리스너 설정
        function setupRoomListeners() {
            [cite_start]if (!gameState.roomRef) return; [cite: 226]
            gameState.roomRef.on('value', (snapshot) => {
                [cite_start]const roomData = snapshot.val(); [cite: 226]
                if (roomData) {
                    gameState.boardSize = roomData.boardSize || [cite_start]3; [cite: 227]
                    gameState.maxPlayers = roomData.maxPlayers || [cite_start]2; [cite: 227]
                    [cite_start]gameState.gameStarted = roomData.gameStarted || false; [cite: 227]
                    gameState.winCondition = roomData.winCondition || [cite_start]1; [cite: 227]
                    [cite_start]gameState.currentTurn = roomData.currentTurn !== null ? roomData.currentTurn : 0; [cite: 228]
                    gameState.missionMap = roomData.missionMap || [cite_start]{}; [cite: 228]
                    [cite_start]gameState.flippedNumbers = Object.keys(roomData.flippedNumbers || {}).map(Number); [cite: 228]
                    
                    if (roomData.players) {
                        [cite_start]gameState.players = roomData.players; [cite: 229]
                        gameState.playerList = roomData.playerOrderUids || [cite_start][]; [cite: 229]
                    } else {
                        [cite_start]gameState.players = {}; [cite: 230]
                        [cite_start]gameState.playerList = []; [cite: 230]
                    }
                    [cite_start]updatePlayersDisplay(); [cite: 231]
                    // 호스트가 아니더라도 Firebase에서 미션 목록을 받아와 업데이트
                    gameState.missions = roomData.missions || [cite_start][]; [cite: 232]
                    [cite_start]updateMissionsDisplay(); [cite: 232]

                    if (gameState.gameStarted) {
                        [cite_start]document.getElementById('game-setup').style.display = 'none'; [cite: 233]
                        [cite_start]document.getElementById('game-area').style.display = 'block'; [cite: 233]
                        [cite_start]document.getElementById('current-room-code').textContent = gameState.roomCode; [cite: 233]
                        [cite_start]document.getElementById('flipped-numbers-count').textContent = gameState.flippedNumbers.length; [cite: 234]
                        
                        [cite_start]const totalCells = gameState.boardSize * gameState.boardSize; [cite: 234]
                        if (gameState.bingoBoard.length !== totalCells || document.getElementById('bingo-board').children.length !== totalCells) {
                                if (Object.keys(gameState.missionMap).length === totalCells) {
                                    [cite_start]generateBingoBoard(); [cite: 235]
                                }
                        }
                    } else {
                        [cite_start]document.getElementById('game-setup').style.display = 'block'; [cite: 236]
                        [cite_start]document.getElementById('game-area').style.display = 'none'; [cite: 236]
                    }

                    // 턴 디스플레이 업데이트 로직 제거
                    [cite_start]// updateTurnDisplay(); [cite: 237]

                    if (gameState.players[gameState.playerUID] && gameState.players[gameState.playerUID].boardState) {
                        [cite_start]syncBingoBoard(gameState.players[gameState.playerUID].boardState); [cite: 238]
                    } else {
                        [cite_start]syncBingoBoard({}); [cite: 239]
                    }
                    
                    [cite_start]checkBingoPossibility(); [cite: 240]
                    [cite_start]updateBingoCellClickability(); [cite: 240]
                    
                    // 선공 플레이어 섹션 활성화/비활성화 로직 제거
                    // if (gameState.isHost && gameState.playerList.length > 1) {
                    [cite_start]//     document.getElementById('first-player-section').classList.remove('hidden'); [cite: 241]
                    [cite_start]//     updateFirstPlayerOptions(); [cite: 241]
                    // } else {
                    [cite_start]//     document.getElementById('first-player-section').classList.add('hidden'); [cite: 242]
                    // }

                    if (roomData.winner) {
                        [cite_start]displayWinnerMessage(roomData.winner, roomData.winCondition); [cite: 243]
                        [cite_start]document.getElementById('bingo-button').disabled = true; [cite: 243]
                        // 턴 종료 버튼 disabled 로직 제거
                        // document.getElementById('turn-end-button').disabled = true;
                        [cite_start]document.getElementById('bingo-button').style.display = 'none'; [cite: 243]
                        // 턴 종료 버튼 display 로직 제거
                        [cite_start]// document.getElementById('turn-end-button').style.display = 'none'; [cite: 244]
                    } else {
                        [cite_start]const winnerOverlay = document.getElementById('winner-overlay'); [cite: 245]
                        [cite_start]if (winnerOverlay) winnerOverlay.remove(); [cite: 245]
                        if (gameState.gameStarted) {
                            [cite_start]document.getElementById('bingo-button').style.display = 'block'; [cite: 246]
                            // 턴 종료 버튼 display 로직 제거
                            [cite_start]// document.getElementById('turn-end-button').style.display = 'block'; [cite: 246]
                        }
                    }
                    // 미션 추가 버튼 활성화/비활성화
                    [cite_start]document.getElementById('add-mission-btn').disabled = !gameState.roomCode; [cite: 247]
                }
            [cite_start]}); [cite: 248]
        }

        // 미션 추가
        async function addMission() {
            if (!gameState.roomCode) {
                [cite_start]showMessage('먼저 방에 입장하거나 생성해주세요!', 'error'); [cite: 249]
                return;
            }

            [cite_start]const missionInput = document.getElementById('mission-input'); [cite: 250]
            [cite_start]const mission = missionInput.value.trim(); [cite: 250]
            
            if (!mission) {
                [cite_start]showMessage('미션 내용을 입력해주세요!', 'error'); [cite: 251]
                return;
            }
            
            // Firebase에서 최신 미션 목록을 가져와 중복 확인
            [cite_start]const snapshot = await gameState.roomRef.child('missions').once('value'); [cite: 252]
            const currentMissionsInFirebase = snapshot.val() || [cite_start][]; [cite: 252]

            if (currentMissionsInFirebase.includes(mission)) {
                [cite_start]showMessage('이미 추가된 미션입니다!', 'error'); [cite: 253]
                return;
            }
            
            try {
                // 트랜잭션을 사용하여 동시성 문제 방지
                await gameState.roomRef.child('missions').transaction((currentData) => {
                    const newMissions = currentData || [];
                    if (!newMissions.includes(mission)) {
                        newMissions.push(mission);
                    }
                    [cite_start]return newMissions; [cite: 254]
                [cite_start]}); [cite: 255]
                [cite_start]missionInput.value = ''; [cite: 255]
                [cite_start]showMessage('미션이 추가되었습니다! ✨', 'success'); [cite: 255]
                
            } catch (error) {
                [cite_start]showMessage('미션 추가에 실패했습니다: ' + error.message, 'error'); [cite: 256]
                [cite_start]console.error('미션 추가 오류:', error); [cite: 256]
            }
        }

        // 미션 삭제
        async function deleteMission(index) {
            if (!gameState.isHost) {
                [cite_start]showMessage('방장만 미션을 삭제할 수 있습니다!', 'error'); [cite: 257]
                return;
            }
            if (!gameState.roomCode) {
                [cite_start]showMessage('방에 입장하지 않았습니다!', 'error'); [cite: 258]
                return;
            }

            try {
                // Firebase에서 최신 미션 목록을 가져와 삭제
                await gameState.roomRef.child('missions').transaction((currentMissions) => {
                    if (currentMissions && currentMissions.length > index) {
                        [cite_start]const newMissions = currentMissions.filter((_, i) => i !== index); [cite: 259]
                        return newMissions;
                    }
                    return undefined; // 트랜잭션 취소
                [cite_start]}); [cite: 260]
                [cite_start]showMessage('미션이 삭제되었습니다! 🗑️', 'success'); [cite: 260]
            } catch (error) {
                [cite_start]showMessage('미션 삭제에 실패했습니다: ' + error.message, 'error'); [cite: 261]
                [cite_start]console.error('미션 삭제 오류:', error); [cite: 261]
            }
        }

        // 미션 저장 함수
        function saveMissions() {
            try {
                [cite_start]localStorage.setItem('savedBingoMissions', JSON.stringify(gameState.missions)); [cite: 262]
                [cite_start]showMessage('현재 미션 목록이 저장되었습니다! ✅', 'success'); [cite: 262]
            } catch (e) {
                [cite_start]showMessage('미션 저장에 실패했습니다. 브라우저 저장 공간이 부족할 수 있습니다.', 'error'); [cite: 263]
                [cite_start]console.error("Failed to save missions to localStorage:", e); [cite: 263]
            }
        }

        // 미션 불러오기 함수
        function loadMissions() {
            try {
                [cite_start]const savedMissions = localStorage.getItem('savedBingoMissions'); [cite: 264]
                if (savedMissions) {
                    [cite_start]gameState.missions = JSON.parse(savedMissions); [cite: 265]
                    [cite_start]showMessage('저장된 미션 목록을 불러왔습니다! 📝', 'success'); [cite: 265]
                } else {
                    [cite_start]gameState.missions = [...defaultMissions]; [cite: 266]
                    [cite_start]showMessage('저장된 미션이 없습니다. 기본 미션 목록을 불러왔습니다. ℹ️', 'info'); [cite: 266]
                }
                [cite_start]updateMissionsDisplay(); [cite: 267]
            } catch (e) {
                [cite_start]showMessage('미션 불러오기에 실패했습니다. ❌', 'error'); [cite: 268]
                [cite_start]console.error("Failed to load missions from localStorage:", e); [cite: 268]
                [cite_start]gameState.missions = [...defaultMissions]; [cite: 269]
                [cite_start]updateMissionsDisplay(); [cite: 269]
            }
        }

        // 게임 시작
        async function startGame() {
            [cite_start]console.log('startGame 함수 시작'); [cite: 270]
            if (!gameState.roomCode) {
                [cite_start]showMessage('먼저 방을 생성하거나 입장해주세요!', 'error'); [cite: 271]
                return;
            }
            
            [cite_start]const requiredMissions = gameState.boardSize * gameState.boardSize; [cite: 272]
            [cite_start]console.log(`필요 미션 수: ${requiredMissions}, 현재 미션 수: ${gameState.missions.length}`); [cite: 272]
            if (gameState.missions.length < requiredMissions) {
                [cite_start]showMessage(`미션이 최소 ${requiredMissions}개 필요합니다! 현재 ${gameState.missions.length}개`, 'error'); [cite: 273]
                return;
            }

            if (!gameState.isHost) {
                [cite_start]showMessage('방장만 게임을 시작할 수 있습니다!', 'error'); [cite: 274]
                return;
            }
            
            [cite_start]console.log(`현재 플레이어 수: ${Object.keys(gameState.players).length}`); [cite: 275]
            if (Object.keys(gameState.players).length < 2) {
                [cite_start]showMessage('게임을 시작하려면 최소 2명 이상의 플레이어가 필요합니다!', 'error'); [cite: 276]
                return;
            }

            // 선공 플레이어 선택 로직 제거
            [cite_start]// const firstPlayerSelect = document.getElementById('first-player-select'); [cite: 277]
            [cite_start]// const firstPlayerUid = firstPlayerSelect.value; [cite: 277]
            [cite_start]// console.log(`선택된 선공 플레이어 UID: ${firstPlayerUid}`); [cite: 277]
            // if (!firstPlayerUid) {
            [cite_start]//     showMessage('선공 플레이어를 선택해주세요!', 'error'); [cite: 278]
            //     return;
            // }
            
            [cite_start]// const firstPlayerIndex = gameState.playerList.indexOf(firstPlayerUid); [cite: 279]
            // if (firstPlayerIndex === -1) {
            [cite_start]//     showMessage('선택된 선공 플레이어를 찾을 수 없습니다!', 'error'); [cite: 280]
            //     return;
            // }
            
            [cite_start]console.log('미션 맵 생성 시작'); [cite: 281]
            [cite_start]const shuffledMissions = [...gameState.missions].sort(() => Math.random() - 0.5).slice(0, requiredMissions); [cite: 281]
            [cite_start]const shuffledNumbersForMap = Array.from({length: requiredMissions}, (_, i) => i + 1).sort(() => Math.random() - 0.5); [cite: 282]
            [cite_start]const missionMap = {}; [cite: 282]
            for (let i = 0; i < requiredMissions; i++) {
                [cite_start]missionMap[shuffledNumbersForMap[i]] = shuffledMissions[i]; [cite: 283]
            }
            [cite_start]console.log('생성된 missionMap:', missionMap); [cite: 284]
            try {
                [cite_start]const winCondition = document.querySelector('input[name="win-condition"]:checked').value; [cite: 285]
                [cite_start]const selectedBoardSize = 3; [cite: 285]
                [cite_start]const selectedMaxPlayers = gameState.maxPlayers; [cite: 285]
                
                [cite_start]console.log('Firebase room 업데이트 시도'); [cite: 286]
                await gameState.roomRef.update({
                    gameStarted: true,
                    winCondition: parseInt(winCondition),
                    boardSize: selectedBoardSize,
                    maxPlayers: selectedMaxPlayers,
                    [cite_start]startedAt: firebase.database.ServerValue.TIMESTAMP, [cite: 287]
                    currentTurn: 0, // 선공 선택 로직 제거에 따라 0으로 고정
                    [cite_start]flippedNumbers: {}, [cite: 288]
                    [cite_start]winner: null, [cite: 288]
                    [cite_start]gameEnded: false, [cite: 288]
                    [cite_start]missionMap: missionMap, [cite: 288]
                    [cite_start]bingoClaimed: null [cite: 289]
                [cite_start]}); [cite: 289]
                [cite_start]console.log('Firebase room 업데이트 성공'); [cite: 289]

                const updates = {};
                for (const playerUid in gameState.players) {
                    [cite_start]updates[`players/${playerUid}/boardState`] = {}; [cite: 290]
                }
                [cite_start]await gameState.roomRef.update(updates); [cite: 291]
                [cite_start]console.log('플레이어 boardState 초기화 성공'); [cite: 291]
                
            } catch (error) {
                [cite_start]showMessage('게임 시작에 실패했습니다: ' + error.message, 'error'); [cite: 292]
                [cite_start]console.error('게임 시작 오류:', error); [cite: 293]
            }
            [cite_start]console.log('startGame 함수 종료'); [cite: 293]
        }

        // 선공 플레이어 옵션 업데이트 (더 이상 사용되지 않음)
        // function updateFirstPlayerOptions() {
        [cite_start]//     const firstPlayerSelect = document.getElementById('first-player-select'); [cite: 294]
        [cite_start]//     firstPlayerSelect.innerHTML = '<option value="">선공을 선택하세요</option>'; [cite: 294]
            
        //     gameState.playerList.forEach(playerUid => {
        //         const playerName = gameState.players[playerUid]?.name || 'Unknown Player';
        //         const option = document.createElement('option');
        //         option.value = playerUid;
        //         option.textContent = playerName;
        [cite_start]//         firstPlayerSelect.appendChild(option); [cite: 295]
        [cite_start]//     }); [cite: 296]
        //     if (gameState.currentTurn !== null && gameState.playerList[gameState.currentTurn]) {
        [cite_start]//         firstPlayerSelect.value = gameState.playerList[gameState.currentTurn]; [cite: 297]
        //     }
        // }

        // 턴 표시 업데이트 (더 이상 사용되지 않음)
        // function updateTurnDisplay() {
        [cite_start]//     const turnElement = document.getElementById('current-turn'); [cite: 298]
        //     if (turnElement && gameState.playerList.length > 0) {
        [cite_start]//         const currentPlayerUid = gameState.playerList[gameState.currentTurn]; [cite: 299]
        //         const currentPlayerName = gameState.players[currentPlayerUid]?.name || [cite_start]'알 수 없음'; [cite: 299]
        [cite_start]//         const isMyTurn = currentPlayerUid === gameState.playerUID; [cite: 300]
        //         if (isMyTurn) {
        [cite_start]//             turnElement.innerHTML = '<span style="color: #667eea; font-weight: bold;">당신의 차례입니다!</span>'; [cite: 301]
        //         } else {
        [cite_start]//             turnElement.textContent = `${currentPlayerName}의 차례`; [cite: 302]
        //         }
        //     }
        // }

        // 빙고판 UI 동기화
        function syncBingoBoard(myBoardStateData) {
            [cite_start]const totalCells = gameState.boardSize * gameState.boardSize; [cite: 303]
            if (Object.keys(gameState.missionMap).length === 0 || gameState.bingoBoard.length === 0) {
                if (gameState.gameStarted && Object.keys(gameState.missionMap).length === totalCells) {
                    [cite_start]generateBingoBoard(); [cite: 304]
                } else if (gameState.gameStarted && Object.keys(gameState.missionMap).length === 0) {
                    [cite_start]console.warn("syncBingoBoard: Waiting for missionMap to load..."); [cite: 305]
                    [cite_start]setTimeout(() => syncBingoBoard(myBoardStateData), 100); [cite: 305]
                    return;
                } else {
                    [cite_start]return; [cite: 306]
                }
            }
            
            [cite_start]const bingoBoardElement = document.getElementById('bingo-board'); [cite: 307]
            if (bingoBoardElement.children.length === 0 || bingoBoardElement.children.length !== totalCells) {
                [cite_start]console.warn("syncBingoBoard: Waiting for bingo board DOM to be generated..."); [cite: 308]
                [cite_start]setTimeout(() => syncBingoBoard(myBoardStateData), 50); [cite: 308]
                return;
            }

            [cite_start]const cells = bingoBoardElement.querySelectorAll('.bingo-cell'); [cite: 309]
            for (let i = 0; i < totalCells; i++) {
                [cite_start]const cellInLocalBoard = gameState.bingoBoard[i]; [cite: 310]
                [cite_start]const cellNumber = cellInLocalBoard.number; [cite: 310]
                [cite_start]const missionText = cellInLocalBoard.mission; [cite: 310]

                [cite_start]const isFlippedCommon = gameState.flippedNumbers.includes(cellNumber); [cite: 311]
                [cite_start]const myCellStateFromFirebase = myBoardStateData[cellNumber] ? myBoardStateData[cellNumber].state : 'unflipped'; [cite: 311]
                [cite_start]const cellElement = cells[i]; [cite: 311]
                [cite_start]cellElement.classList.remove('flipped', 'failed'); [cite: 311]

                if (isFlippedCommon) {
                    if (myCellStateFromFirebase === 'flipped') {
                        [cite_start]cellElement.classList.add('flipped'); [cite: 312]
                        [cite_start]cellElement.textContent = missionText; [cite: 312]
                    } else if (myCellStateFromFirebase === 'failed') {
                        [cite_start]cellElement.classList.add('failed'); [cite: 313]
                        [cite_start]cellElement.textContent = missionText; [cite: 313]
                    } else {
                        [cite_start]cellElement.classList.add('flipped'); [cite: 314]
                        [cite_start]cellElement.textContent = missionText; [cite: 314]
                        gameState.roomRef.child(`players/${gameState.playerUID}/boardState/${cellNumber}`).set({
                            state: 'flipped',
                            mission: missionText,
                            changedAt: firebase.database.ServerValue.TIMESTAMP
                        [cite_start]}).catch(error => console.error("Auto-flip update failed:", error)); [cite: 315]
                    }
                } else {
                    [cite_start]cellElement.textContent = cellNumber; [cite: 317]
                }
            }
        }

        // 빙고 셀 클릭 가능 여부 업데이트
        function updateBingoCellClickability() {
            [cite_start]const cells = document.querySelectorAll('.bingo-cell'); [cite: 318]
            // const currentPlayerUid = gameState.playerList[gameState.currentTurn]; // 턴 개념 제거
            // const isMyTurn = currentPlayerUid === gameState.playerUID; // 턴 개념 제거
            [cite_start]const gameEnded = gameState.gameStarted && (gameState.roomRef && gameState.roomRef.gameEnded || gameState.roomRef && gameState.roomRef.winner); [cite: 320]

            cells.forEach((cellElement, index) => {
                const cellNumber = gameState.bingoBoard[index].number;
                const isFlippedCommon = gameState.flippedNumbers.includes(cellNumber);

                if (gameEnded) {
                    [cite_start]cellElement.style.pointerEvents = 'none'; [cite: 321]
                    [cite_start]cellElement.style.opacity = '0.7'; [cite: 321]
                } else { // 턴 개념 없이 항상 클릭 가능
                    if (!isFlippedCommon) { // 뒤집히지 않은 셀은 클릭 가능
                        cellElement.style.pointerEvents = 'auto';
                        cellElement.style.opacity = '1';
                    } else { // 이미 뒤집힌 셀도 다시 클릭하여 상태 변경 가능하도록
                        cellElement.style.pointerEvents = 'auto';
                        cellElement.style.opacity = '1';
                    }
                }
            });
        }

        // 빙고 가능 여부 확인
        function checkBingoPossibility() {
            [cite_start]const board = gameState.bingoBoard; [cite: 328]
            [cite_start]const size = gameState.boardSize; [cite: 328]
            [cite_start]const requiredLines = gameState.winCondition; [cite: 328]
            [cite_start]let completedLines = 0; [cite: 328]
            [cite_start]const bingoButton = document.getElementById('bingo-button'); [cite: 328]
            // const turnEndButton = document.getElementById('turn-end-button'); [cite_start]// 턴 종료 버튼 제거 [cite: 329]
            // const currentPlayerUid = gameState.playerList[gameState.currentTurn]; [cite_start]// 턴 개념 제거 [cite: 329]
            // const isMyTurn = currentPlayerUid === gameState.playerUID; [cite_start]// 턴 개념 제거 [cite: 330]

            if (!gameState.gameStarted || !gameState.roomRef) {
                [cite_start]gameState.canClaimBingo = false; [cite: 330]
                [cite_start]bingoButton.disabled = true; [cite: 331]
                // turnEndButton.disabled = true; [cite_start]// 턴 종료 버튼 제거 [cite: 331]
                return;
            }

            gameState.roomRef.once('value').then(snapshot => {
                [cite_start]const roomData = snapshot.val(); [cite: 331]
                [cite_start]if (!roomData) return; [cite: 331]

                if (roomData.gameEnded || roomData.winner) {
                    [cite_start]bingoButton.disabled = true; [cite: 332]
                    // turnEndButton.disabled = true; [cite_start]// 턴 종료 버튼 제거 [cite: 332]
                    [cite_start]bingoButton.style.display = 'none'; [cite: 332]
                    // turnEndButton.style.display = 'none'; [cite_start]// 턴 종료 버튼 제거 [cite: 332]
                    [cite_start]return; [cite: 332]
                } else {
                    [cite_start]bingoButton.style.display = 'block'; [cite: 332]
                    // turnEndButton.style.display = 'block'; [cite_start]// 턴 종료 버튼 제거 [cite: 332]
                }

                // 빙고 라인 체크
                for (let i = 0; i < size; i++) {
                    [cite_start]let rowComplete = true; [cite: 333]
                    for (let j = 0; j < size; j++) {
                        [cite_start]const index = i * size + j; [cite: 333]
                        if (!board[index] || !roomData.players[gameState.playerUID] || !roomData.players[gameState.playerUID].boardState || roomData.players[gameState.playerUID].boardState[board[index].number]?.state !== 'flipped') {
                            [cite_start]rowComplete = false; [cite: 334]
                            [cite_start]break; [cite: 335]
                        }
                    }
                    [cite_start]if (rowComplete) completedLines++; [cite: 336]
                }

                for (let j = 0; j < size; j++) {
                    [cite_start]let colComplete = true; [cite: 337]
                    for (let i = 0; i < size; i++) {
                        [cite_start]const index = i * size + j; [cite: 338]
                        if (!board[index] || !roomData.players[gameState.playerUID] || !roomData.players[gameState.playerUID].boardState || roomData.players[gameState.playerUID].boardState[board[index].number]?.state !== 'flipped') {
                            [cite_start]colComplete = false; [cite: 339]
                            [cite_start]break; [cite: 339]
                        }
                    }
                    [cite_start]if (colComplete) completedLines++; [cite: 340]
                }

                [cite_start]let diag1Complete = true; [cite: 341]
                for (let i = 0; i < size; i++) {
                    [cite_start]const index = i * size + i; [cite: 342]
                    if (!board[index] || !roomData.players[gameState.playerUID] || !roomData.players[gameState.playerUID].boardState || roomData.players[gameState.playerUID].boardState[board[index].number]?.state !== 'flipped') {
                        [cite_start]diag1Complete = false; [cite: 343]
                        [cite_start]break; [cite: 343]
                    }
                }
                [cite_start]if (diag1Complete) completedLines++; [cite: 344]
                [cite_start]let diag2Complete = true; [cite: 344]
                for (let i = 0; i < size; i++) {
                    [cite_start]const index = i * size + (size - 1 - i); [cite: 345]
                    if (!board[index] || !roomData.players[gameState.playerUID] || !roomData.players[gameState.playerUID].boardState || roomData.players[gameState.playerUID].boardState[board[index].number]?.state !== 'flipped') {
                        [cite_start]diag2Complete = false; [cite: 346]
                        [cite_start]break; [cite: 346]
                    }
                }
                [cite_start]if (diag2Complete) completedLines++; [cite: 347]
                [cite_start]console.log(`${gameState.playerName}: 현재 완성된 라인 수 = ${completedLines}`); [cite: 347]

                if (completedLines >= requiredLines) {
                    [cite_start]gameState.canClaimBingo = true; [cite: 348]
                    [cite_start]bingoButton.disabled = roomData.gameEnded || roomData.winner; [cite: 349] 
                } else {
                    [cite_start]gameState.canClaimBingo = false; [cite: 350]
                    [cite_start]bingoButton.disabled = true; [cite: 350]
                }

                // 턴 종료 버튼 관련 로직 제거
                // turnEndButton.disabled = !isMyTurn || roomData.gameEnded || roomData.winner || [cite_start]!gameState.hasMadeMoveInTurn; [cite: 351]

            }).catch(error => {
                [cite_start]console.error("Error checking bingo possibility:", error); [cite: 352]
                [cite_start]showMessage("빙고/턴 상태 확인 중 오류 발생!", "error"); [cite: 352]
                [cite_start]bingoButton.disabled = true; [cite: 352]
                // turnEndButton.disabled = true; [cite_start]// 턴 종료 버튼 제거 [cite: 352]
            [cite_start]}); [cite: 352]
        }

        // 턴 종료 함수 제거
        // async function turnEnd() {
        [cite_start]//     const currentPlayerUid = gameState.playerList[gameState.currentTurn]; [cite: 353]
        //     if (currentPlayerUid !== gameState.playerUID) {
        [cite_start]//         showMessage('당신의 차례가 아닙니다!', 'error'); [cite: 354]
        //         return;
        //     }

        [cite_start]//     const roomSnapshot = await gameState.roomRef.once('value'); [cite: 355]
        [cite_start]//     const roomData = roomSnapshot.val(); [cite: 355]

        //     if (roomData.gameEnded || roomData.winner) {
        [cite_start]//         showMessage('게임은 이미 종료되었습니다!', 'error'); [cite: 356]
        //         return;
        //     }

        //     if (!gameState.hasMadeMoveInTurn) {
        [cite_start]//         showMessage('셀을 하나라도 뒤집어야 턴을 종료할 수 있습니다!', 'error'); [cite: 357]
        //         return;
        //     }

        //     try {
        [cite_start]//         const nextTurn = (gameState.currentTurn + 1) % gameState.playerList.length; [cite: 358]
        //         await gameState.roomRef.update({
        //             currentTurn: nextTurn
        [cite_start]//         }); [cite: 359]
        [cite_start]//         showMessage('턴을 종료했습니다.', 'info'); [cite: 359]
        [cite_start]//         gameState.hasMadeMoveInTurn = false; [cite: 359]
        [cite_start]//         document.getElementById('turn-end-button').disabled = true; [cite: 359]
        [cite_start]//         document.getElementById('bingo-button').disabled = true; [cite: 360]
        //     } catch (error) {
        [cite_start]//         showMessage('턴 종료에 실패했습니다: ' + error.message, 'error'); [cite: 361]
        [cite_start]//         console.error('Turn End Error:', error); [cite: 361]
        //     }
        // }

        // 빙고 승리 주장
        async function claimBingo() {
            if (!gameState.canClaimBingo) {
                [cite_start]showMessage('빙고를 주장할 수 없습니다. 조건을 다시 확인하세요!', 'error'); [cite: 362]
                return;
            }
            
            [cite_start]const roomSnapshot = await gameState.roomRef.once('value'); [cite: 363]
            [cite_start]const roomData = roomSnapshot.val(); [cite: 363]

            if (roomData.gameEnded || roomData.winner) {
                [cite_start]showMessage('게임은 이미 종료되었거나 승자가 결정되었습니다!', 'error'); [cite: 364]
                return;
            }
            
            if (roomData.bingoClaimed) {
                [cite_start]showMessage('다른 플레이어가 이미 빙고를 주장했습니다!', 'error'); [cite: 365]
                return;
            }

            try {
                const result = await gameState.roomRef.child('bingoClaimed').transaction((currentClaim) => {
                    if (currentClaim === null) {
                        return {
                            [cite_start]claimerUid: gameState.playerUID, [cite: 366]
                            [cite_start]claimerName: gameState.playerName, [cite: 366]
                            [cite_start]timestamp: firebase.database.ServerValue.TIMESTAMP [cite: 367]
                        [cite_start]}; [cite: 367]
                    } else {
                        [cite_start]return undefined; [cite: 367]
                    }
                [cite_start]}); [cite: 368]
                if (result.committed) {
                    await gameState.roomRef.update({
                        winner: gameState.playerName,
                        winnerUid: gameState.playerUID,
                        gameEnded: true,
                        [cite_start]endedAt: firebase.database.ServerValue.TIMESTAMP [cite: 369]
                    [cite_start]}); [cite: 370]
                    [cite_start]showMessage('🎉 빙고를 주장했습니다! 당신이 승리합니다!', 'success'); [cite: 370]
                } else {
                    [cite_start]showMessage('앗! 다른 플레이어가 먼저 빙고를 주장했습니다!', 'error'); [cite: 371]
                }
                [cite_start]document.getElementById('bingo-button').disabled = true; [cite: 372]
                [cite_start]document.getElementById('bingo-button').style.display = 'none'; [cite: 372]
                // 턴 종료 버튼 display 로직 제거
                [cite_start]// document.getElementById('turn-end-button').style.display = 'none'; [cite: 372]
            } catch (error) {
                [cite_start]showMessage('빙고 주장 중 오류가 발생했습니다: ' + error.message, 'error'); [cite: 373]
                [cite_start]console.error('Claim Bingo Error:', error); [cite: 373]
            }
        }

        // 승리 메시지 표시
        function displayWinnerMessage(winnerName, winCondition) {
            if (document.getElementById('winner-overlay')) {
                [cite_start]return; [cite: 374]
            }

            const overlay = document.createElement('div');
            [cite_start]overlay.classList.add('winner-overlay'); [cite: 375]
            [cite_start]overlay.id = 'winner-overlay'; [cite: 375]
            [cite_start]const messageBox = document.createElement('div'); [cite: 375]
            [cite_start]messageBox.classList.add('winner-message'); [cite: 375]
            messageBox.innerHTML = `
                <p class="emoji">🎉🏆</p>
                <p class="winner-text gradient-text">${winnerName}님</p>
                <p class="winner-text gradient-text">${winCondition}줄 빙고로 승리했습니다!</p>
                <button class="btn btn-primary" onclick="closeWinnerMessage()">확인</button>
            [cite_start]`; [cite: 376]
            [cite_start]overlay.appendChild(messageBox); [cite: 376]
            [cite_start]document.body.appendChild(overlay); [cite: 376]
        }

        // 승리 메시지 닫기
        function closeWinnerMessage() {
            [cite_start]const overlay = document.getElementById('winner-overlay'); [cite: 377]
            if (overlay) {
                [cite_start]overlay.remove(); [cite: 378]
                if (confirm('설정 화면으로 돌아가시겠습니까?')) {
                    [cite_start]backToSetup(); [cite: 379]
                }
            }
        }

        // 설정 화면으로 돌아가기
        function backToSetup() {
            [cite_start]document.getElementById('game-setup').style.display = 'block'; [cite: 380]
            [cite_start]document.getElementById('game-area').style.display = 'none'; [cite: 380]
            
            if (gameState.roomRef && gameState.playerUID) {
                [cite_start]gameState.roomRef.off(); [cite: 381]
                // 플레이어가 방을 나갈 때만 Firebase에서 플레이어 정보 삭제
                // 호스트가 나갈 때 방 전체를 삭제하는 로직은 추가하지 않음 (게임의 일관성을 위해)
                gameState.roomRef.child('players').child(gameState.playerUID).remove()
                    .then(() => {
                        [cite_start]console.log(`플레이어 ${gameState.playerName}이(가) 방을 나갑니다. UID: ${gameState.playerUID}`); [cite: 382]
                        // playerOrderUids 배열에서도 해당 UID 제거
                        gameState.roomRef.child('playerOrderUids').transaction((currentUids) => {
                            if (currentUids) {
                                [cite_start]return currentUids.filter(uid => uid !== gameState.playerUID); [cite: 383]
                            }
                            [cite_start]return []; [cite: 384]
                        [cite_start]}); [cite: 384]
                    })
                    .catch(error => {
                        [cite_start]console.error("방 나가기 중 오류 발생:", error); [cite: 385]
                    [cite_start]}); [cite: 385]
            }
            
            [cite_start]const oldPlayerUID = gameState.playerUID; [cite: 386]
            gameState = {
                [cite_start]isHost: false, [cite: 386]
                [cite_start]roomCode: '', [cite: 386]
                [cite_start]playerName: '', [cite: 386]
                [cite_start]playerUID: oldPlayerUID, [cite: 387]
                [cite_start]players: {}, [cite: 387]
                [cite_start]missions: [], [cite: 387]
                isAuthReady: true, // 로그인 상태 유지
                [cite_start]winCondition: 1, [cite: 387]
                [cite_start]boardSize: 3, [cite: 388]
                [cite_start]maxPlayers: 2, [cite: 388]
                [cite_start]gameStarted: false, [cite: 388]
                [cite_start]bingoBoard: [], [cite: 388]
                currentTurn: 0, // 턴 개념 제거 후에도 초기화는 0으로
                [cite_start]playerList: [], [cite: 388]
                [cite_start]roomRef: null, [cite: 389]
                [cite_start]missionMap: {}, [cite: 389]
                [cite_start]canClaimBingo: false, [cite: 389]
                [cite_start]flippedNumbers: [], [cite: 389]
                hasMadeMoveInTurn: false // 더 이상 사용되지 않지만 초기화는 유지
            [cite_start]}; [cite: 390]
            // UI 초기화
            [cite_start]document.getElementById('players-list').innerHTML = '<div class="loading">방에 입장하면 참가자가 표시됩니다</div>'; [cite: 390]
            [cite_start]document.getElementById('missions-list').innerHTML = `<div style="text-align: center; color: #a0aec0; padding: 20px;">미션을 추가해주세요 (최소 ${gameState.boardSize * gameState.boardSize}개 필요)</div>`; [cite: 391]
            [cite_start]document.getElementById('current-mission-count').textContent = '현재 등록된 미션: 0개'; [cite: 392]
            [cite_start]document.getElementById('share-section').classList.add('hidden'); [cite: 392]
            [cite_start]document.getElementById('join-room-section').classList.add('hidden'); [cite: 392]
            [cite_start]document.getElementById('auto-join-hint').classList.add('hidden'); [cite: 392]
            
            [cite_start]document.getElementById('create-room-btn').classList.remove('hidden-by-url-param'); [cite: 392]
            [cite_start]document.getElementById('max-players-create-group').classList.remove('hidden-by-url-param'); [cite: 393]
            [cite_start]document.getElementById('main-action-buttons').classList.remove('hidden-by-url-param'); [cite: 393]

            [cite_start]document.getElementById('room-code').readOnly = false; [cite: 393]
            // 선공 플레이어 섹션 숨김 유지
            [cite_start]document.getElementById('first-player-section').classList.add('hidden'); [cite: 242] // 이 부분은 원래 hidden이었으므로 추가합니다.
            [cite_start]document.getElementById('player-name').value = ''; [cite: 393]
            [cite_start]document.getElementById('room-code').value = ''; [cite: 393]
            [cite_start]document.getElementById('bingo-button').style.display = 'block'; [cite: 393]
            [cite_start]document.getElementById('bingo-button').disabled = true; [cite: 394]
            // 턴 종료 버튼 display 및 disabled 로직 제거
            [cite_start]// document.getElementById('turn-end-button').style.display = 'block'; [cite: 394]
            [cite_start]// document.getElementById('turn-end-button').disabled = true; [cite: 394]
            
            [cite_start]const winnerOverlay = document.getElementById('winner-overlay'); [cite: 394]
            if (winnerOverlay) {
                [cite_start]winnerOverlay.remove(); [cite: 395]
            }

            [cite_start]document.getElementById('size-3').checked = true; [cite: 395]
            [cite_start]document.getElementById('win-1').checked = true; [cite: 396]
            [cite_start]document.getElementById('max-players-create').value = 2; [cite: 396]
            [cite_start]document.getElementById('flipped-numbers-count').textContent = '0'; [cite: 396]
            [cite_start]document.getElementById('game-options-section').classList.remove('hidden'); [cite: 396]

            [cite_start]loadMissions(); [cite: 396]
            [cite_start]updateButtonStates(); [cite: 396]
        }

        // 방 코드 생성
        function generateRoomCode() {
            [cite_start]const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; [cite: 397]
            [cite_start]let result = ''; [cite: 397]
            for (let i = 0; i < 6; i++) {
                [cite_start]result += chars.charAt(Math.floor(Math.random() * chars.length)); [cite: 398]
            }
            [cite_start]return result; [cite: 399]
        }

        // 플레이어 목록 업데이트
        function updatePlayersDisplay() {
            [cite_start]const playersList = document.getElementById('players-list'); [cite: 400]
            [cite_start]const playersArray = Object.values(gameState.players); [cite: 400]
            
            if (playersArray.length === 0) {
                [cite_start]playersList.innerHTML = '<div class="loading">방에 입장하면 참가자가 표시됩니다</div>'; [cite: 401]
                return;
            }
            
            // playerList (UID 순서)에 따라 정렬하여 표시
            const sortedPlayers = gameState.playerList
                .map(uid => gameState.players[uid])
                [cite_start].filter(player => player !== undefined); [cite: 402] // 방을 나간 플레이어는 제외

            playersList.innerHTML = sortedPlayers.map(player =>
                `<div class="player-item ${player.isHost ? 'host' : ''}">
                    ${player.isHost ? '👑' : '👤'} ${player.name} ${player.isHost ? '(방장)' : ''}
                </div>`
            [cite_start]).join(''); [cite: 403]
            [cite_start]const startBtn = document.getElementById('start-game-btn'); [cite: 403]
            if (gameState.isHost) {
                [cite_start]startBtn.style.display = 'block'; [cite: 404]
                [cite_start]startBtn.textContent = '🎮 게임 시작!'; [cite: 404]
                [cite_start]startBtn.disabled = false; [cite: 404]
            } else {
                [cite_start]startBtn.style.display = 'block'; [cite: 405]
                [cite_start]startBtn.textContent = '방장이 게임을 시작하기를 기다리는 중...'; [cite: 405]
                [cite_start]startBtn.disabled = true; [cite: 406]
            }
        }

        // 미션 목록 UI 업데이트
        function updateMissionsDisplay() {
            [cite_start]const missionsList = document.getElementById('missions-list'); [cite: 407]
            [cite_start]const requiredMissions = gameState.boardSize * gameState.boardSize; [cite: 407]

            if (gameState.missions.length === 0) {
                [cite_start]missionsList.innerHTML = `<div style="text-align: center; color: #a0aec0; padding: 20px;">미션을 추가해주세요 (최소 ${requiredMissions}개 필요)</div>`; [cite: 408]
            } else {
                missionsList.innerHTML = gameState.missions.map((mission, index) =>
                    `<div class="mission-item">
                        <span>📌 ${mission}</span>
                        ${gameState.isHost ? `<button class="delete-btn" onclick="deleteMission(${index})">삭제</button>` : ''}
                    [cite_start]</div>` [cite: 409]
                [cite_start]).join(''); [cite: 410]
            }

            [cite_start]document.getElementById('current-mission-count').textContent = `현재 등록된 미션: ${gameState.missions.length}개`; [cite: 411]
        }

        // 빙고판 생성
        function generateBingoBoard() {
            [cite_start]const size = gameState.boardSize; [cite: 412]
            [cite_start]const totalCells = size * size; [cite: 412]

            if (Object.keys(gameState.missionMap).length === 0 || Object.keys(gameState.missionMap).length !== totalCells) {
                [cite_start]console.warn('generateBingoBoard: Mission map is not fully loaded yet or size mismatch. Retrying in 100ms...'); [cite: 413]
                [cite_start]setTimeout(generateBingoBoard, 100); [cite: 413]
                return;
            }
            
            [cite_start]const bingoBoardElement = document.getElementById('bingo-board'); [cite: 414]
            if (gameState.bingoBoard.length === totalCells && bingoBoardElement.children.length === totalCells && bingoBoardElement.classList.contains(`size-${size}`)) {
                [cite_start]bingoBoardElement.className = `bingo-board size-${size}`; [cite: 415]
                return;
            }

            [cite_start]const numbers = Array.from({length: totalCells}, (_, i) => i + 1); [cite: 416]
            [cite_start]const shuffledNumbers = numbers.sort(() => Math.random() - 0.5); [cite: 416]
            
            gameState.bingoBoard = shuffledNumbers.map((num) => ({
                number: num,
                state: 'unflipped',
                mission: gameState.missionMap[num] || `미션 ${num}`
            [cite_start]})); [cite: 417]
            [cite_start]bingoBoardElement.className = `bingo-board size-${size}`; [cite: 417]
            bingoBoardElement.innerHTML = gameState.bingoBoard.map((cell, index) =>
                `<div class="bingo-cell" onclick="flipCell(${index})">${cell.number}</div>`
            [cite_start]).join(''); [cite: 418]
            [cite_start]updateBingoCellClickability(); [cite: 418]
        }

        // 셀 뒤집기
        async function flipCell(index) {
            [cite_start]const roomSnapshot = await gameState.roomRef.once('value'); [cite: 419]
            [cite_start]const roomData = roomSnapshot.val(); [cite: 419]
            
            if (roomData.gameEnded || roomData.winner) {
                [cite_start]showMessage('게임이 이미 종료되었거나 승자가 결정되었습니다!', 'error'); [cite: 420]
                return;
            }
            
            [cite_start]const selectedNumber = gameState.bingoBoard[index].number; [cite: 421]
            [cite_start]const missionToAssign = gameState.bingoBoard[index].mission; [cite: 421]
            // const currentPlayerUidInRoom = gameState.playerList[gameState.currentTurn]; [cite_start]// 턴 개념 제거 [cite: 421]
            // const isMyTurn = gameState.playerUID === currentPlayerUidInRoom; [cite_start]// 턴 개념 제거 [cite: 422]

            try {
                [cite_start]const isFlippedCommon = gameState.flippedNumbers.includes(selectedNumber); [cite: 423]
                const myCurrentState = roomData.players[gameState.playerUID]?.boardState?.[selectedNumber]?.state || [cite_start]'unflipped'; [cite: 423]

                if (!isFlippedCommon) { // 아직 뒤집히지 않은 셀인 경우
                    // 턴 확인 로직 제거
                    [cite_start]// if (isMyTurn) { [cite: 424]
                    //     if (gameState.hasMadeMoveInTurn) {
                    [cite_start]//         showMessage('한 턴에 하나의 숫자만 뒤집을 수 있습니다!', 'error'); [cite: 424]
                    //         return;
                    //     }

                        const flippedResult = await gameState.roomRef.child('flippedNumbers').child(selectedNumber).transaction((currentValue) => {
                            if (currentValue === null) {
                                [cite_start]return true; [cite: 425]
                            }
                            [cite_start]return undefined; [cite: 426]
                        [cite_start]}); [cite: 426]
                        if (!flippedResult.committed) {
                            [cite_start]showMessage('이미 다른 플레이어가 이 숫자를 뒤집었거나 문제가 발생했습니다.', 'error'); [cite: 427]
                            return;
                        }
                        // gameState.hasMadeMoveInTurn = true; [cite_start]// 턴 개념 제거 [cite: 428]
                    // } else {
                    //     const currentPlayerNameForMsg = gameState.players[currentPlayerUidInRoom]?.name || [cite_start]'알 수 없는 플레이어'; [cite: 429]
                    [cite_start]//     showMessage(`${currentPlayerNameForMsg}의 차례입니다. 새로운 숫자를 선택할 수 없습니다!`, 'error'); [cite: 430]
                    [cite_start]//     return; [cite: 430]
                    // }
                }

                [cite_start]const myBoardStateRef = gameState.roomRef.child(`players/${gameState.playerUID}/boardState/${selectedNumber}`); [cite: 431]
                const boardStateResult = await myBoardStateRef.transaction((currentMyStateData) => {
                    [cite_start]let stateForMeInFirebase = currentMyStateData ? currentMyStateData.state : 'unflipped'; [cite: 431]
                    [cite_start]let nextStateForMe; [cite: 431]

                    if (isFlippedCommon) { // 이미 공통으로 뒤집힌 셀
                        if (stateForMeInFirebase === 'flipped') { // 파란색 -> 빨간색
                            nextStateForMe = 'failed';
                        } else if (stateForMeInFirebase === 'failed') { // 빨간색 -> 파란색
                            [cite_start]nextStateForMe = 'flipped'; [cite: 433]
                        } else { // 기본값(unflipped) -> 파란색 (다른 사람이 뒤집은 걸 처음 보는 경우)
                            [cite_start]nextStateForMe = 'flipped'; [cite: 433]
                        }
                    } else { // 아직 공통으로 뒤집히지 않은 셀 (지금 막 뒤집으려는 경우)
                        if (stateForMeInFirebase === 'unflipped') { // 뒤집히지 않음 -> 파란색
                            [cite_start]nextStateForMe = 'flipped'; [cite: 434]
                        } else if (stateForMeInFirebase === 'failed') { // 빨간색(이전 게임 등) -> 뒤집히지 않음 (새로운 게임이라 리셋)
                            [cite_start]nextStateForMe = 'unflipped'; [cite: 435]
                        } else { // 그 외의 경우 (예외 처리)
                            [cite_start]return undefined; [cite: 436]
                        }
                    }
                    
                    return {
                        [cite_start]state: nextStateForMe, [cite: 437]
                        [cite_start]mission: missionToAssign, [cite: 437]
                        [cite_start]changedAt: firebase.database.ServerValue.TIMESTAMP [cite: 438]
                    [cite_start]}; [cite: 438]
                [cite_start]}); [cite: 438]

                if (!boardStateResult.committed) {
                    [cite_start]showMessage('내 빙고판 칸 상태 변경 중 오류가 발생했습니다. 다시 시도해주세요!', 'error'); [cite: 439]
                }
                
            } catch (error) {
                [cite_start]showMessage('셀 업데이트에 실패했습니다: ' + error.message, 'error'); [cite: 440]
                [cite_start]console.error('Firebase Transaction Error:', error); [cite: 440]
            }
        }

        // 공유 링크 복사
        function copyShareLink() {
            [cite_start]const shareLinkInput = document.getElementById('share-link'); [cite: 441]
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareLinkInput.value)
                    .then(() => {
                        showMessage('링크가 클립보드에 복사되었습니다! 📋', 'success');
                    [cite_start]}) [cite: 442]
                    .catch(err => {
                        [cite_start]console.error('클립보드 복사 실패:', err); [cite: 442]
                        try {
                            [cite_start]shareLinkInput.select(); [cite: 443]
                            [cite_start]shareLinkInput.setSelectionRange(0, 99999); [cite: 443]
                            [cite_start]document.execCommand('copy'); [cite: 443]
                            [cite_start]showMessage('링크가 복사되었습니다! (구형 방식) 📋', 'success'); [cite: 444]
                        } catch (execErr) {
                            [cite_start]prompt('링크를 수동으로 복사하세요:', shareLinkInput.value); [cite: 444]
                        }
                    [cite_start]}); [cite: 445]
            } else {
                try {
                    [cite_start]shareLinkInput.select(); [cite: 446]
                    [cite_start]shareLinkInput.setSelectionRange(0, 99999); [cite: 446]
                    [cite_start]document.execCommand('copy'); [cite: 446]
                    [cite_start]showMessage('링크가 복사되었습니다! (구형 방식) 📋', 'success'); [cite: 447]
                } catch (execErr) {
                    [cite_start]prompt('링크를 수동으로 복사하세요:', shareLinkInput.value); [cite: 447]
                }
            }
        }

        // URL 파라미터 확인 및 자동 입장
        function checkURLParams() {
            [cite_start]const urlParams = new URLSearchParams(window.location.search); [cite: 448]
            [cite_start]const roomCode = urlParams.get('room'); [cite: 448]
            
            if (roomCode) {
                [cite_start]const upperRoomCode = roomCode.toUpperCase(); [cite: 449]
                [cite_start]console.log('🎯 URL에서 방 코드 발견:', upperRoomCode); [cite: 449]
                
                setTimeout(() => performAutoJoin(upperRoomCode), 0);
                [cite_start]return true; [cite: 450]
            } else {
                [cite_start]console.log('❌ URL에 방 코드 없음'); [cite: 451]
                return false;
            }
        }

        // 자동 입장 실행
        function performAutoJoin(roomCode) {
            [cite_start]console.log('🚀 자동 입장 프로세스 시작:', roomCode); [cite: 452]
            [cite_start]const joinSection = document.getElementById('join-room-section'); [cite: 452]
            [cite_start]const roomCodeInput = document.getElementById('room-code'); [cite: 452]
            [cite_start]const nameInput = document.getElementById('player-name'); [cite: 453]
            [cite_start]const hintElement = document.getElementById('auto-join-hint'); [cite: 453]
            [cite_start]const createRoomControls = document.querySelector('.create-room-controls'); [cite: 453]
            [cite_start]const mainActionButtons = document.getElementById('main-action-buttons'); [cite: 453]
            [cite_start]const gameOptionsSection = document.getElementById('game-options-section'); [cite: 454]

            if (!joinSection || !roomCodeInput || !nameInput || !hintElement || !createRoomControls || !mainActionButtons || !gameOptionsSection) {
                [cite_start]console.error('❌ 필요한 DOM 요소를 찾을 수 없음. 재시도합니다.'); [cite: 454]
                [cite_start]setTimeout(() => performAutoJoin(roomCode), 100); [cite: 454]
                return;
            }
            
            [cite_start]console.log('✅ DOM 요소 모두 준비됨'); [cite: 455]
            [cite_start]createRoomControls.classList.add('hidden-by-url-param'); [cite: 455]
            [cite_start]mainActionButtons.classList.add('hidden-by-url-param'); [cite: 455]

            [cite_start]joinSection.classList.remove('hidden'); [cite: 455]
            [cite_start]roomCodeInput.value = roomCode; [cite: 456]
            [cite_start]roomCodeInput.readOnly = true; [cite: 456]
            [cite_start]nameInput.placeholder = '닉네임을 입력하고 입장하세요!'; [cite: 456]
            
            [cite_start]hintElement.classList.remove('hidden'); [cite: 456]
            [cite_start]gameOptionsSection.classList.add('hidden'); [cite: 456]
            if (document.activeElement !== nameInput) {
                [cite_start]nameInput.focus(); [cite: 457]
            [cite_start]} [cite: 457]

            [cite_start]showMessage(`🎉 초대 링크로 접속했습니다! 방 코드: ${roomCode}\n닉네임을 입력하고 입장하세요!`, 'success'); [cite: 458]
            [cite_start]const currentAutoJoinHandler = nameInput._autoJoinHandler; [cite: 458]
            if (currentAutoJoinHandler) {
                [cite_start]nameInput.removeEventListener('keypress', currentAutoJoinHandler); [cite: 459]
            }
            
            const newAutoJoinHandler = function(e) {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    [cite_start]console.log('⚡ Enter 키로 자동 입장 시도'); [cite: 460]
                    joinRoom(roomCode);
                    nameInput.removeEventListener('keypress', newAutoJoinHandler);
                    nameInput._autoJoinHandler = null;
                }
            [cite_start]}; [cite: 461]
            [cite_start]nameInput.addEventListener('keypress', newAutoJoinHandler); [cite: 461]
            [cite_start]nameInput._autoJoinHandler = newAutoJoinHandler; [cite: 462]
            
            [cite_start]console.log('✅ 자동 입장 UI 설정 완료'); [cite: 462]
        }

        // 이벤트 리스너 설정
        document.addEventListener('DOMContentLoaded', () => {
            // 초기 버튼 상태 설정
            [cite_start]updateButtonStates(); [cite: 463]
            
            document.getElementById('mission-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    [cite_start]addMission(); [cite: 463]
                }
            [cite_start]}); [cite: 464]

            document.getElementById('room-code').addEventListener('input', function(e) {
                [cite_start]e.target.value = e.target.value.toUpperCase(); [cite: 464]
            [cite_start]}); [cite: 464]

            document.querySelectorAll('input[name="board-size"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    [cite_start]const newSize = parseInt(radio.value); [cite: 464]
                    [cite_start]gameState.boardSize = newSize; [cite: 465]
                    [cite_start]updateMissionsDisplay(); [cite: 465]
                });
            [cite_start]}); [cite: 465]

            [cite_start]loadMissions(); [cite: 466]
            // 미션 추가 버튼 초기 상태 설정
            [cite_start]document.getElementById('add-mission-btn').disabled = !gameState.roomCode; [cite: 466]
        });

        // 페이지 이탈 시 정리
        window.addEventListener('beforeunload', async function() {
            if (gameState.roomRef && gameState.playerUID) {
                [cite_start]gameState.roomRef.off(); [cite: 467]
                // 플레이어가 방을 나갈 때만 Firebase에서 플레이어 정보 삭제
                // 호스트가 나갈 때 방 전체를 삭제하는 로직은 추가하지 않음 (게임의 일관성을 위해)
                [cite_start]const playerRef = gameState.roomRef.child('players').child(gameState.playerUID); [cite: 467]
                [cite_start]const playerSnapshot = await playerRef.once('value'); [cite: 468]
                if (playerSnapshot.exists()) {
                    [cite_start]await playerRef.remove(); [cite: 468]
                    [cite_start]console.log(`플레이어 ${gameState.playerName}이(가) 방을 나갑니다. UID: ${gameState.playerUID}`); [cite: 468]
                    // playerOrderUids 배열에서도 해당 UID 제거
                    await gameState.roomRef.child('playerOrderUids').transaction((currentUids) => {
                        if (currentUids) {
                            [cite_start]return currentUids.filter(uid => uid !== gameState.playerUID); [cite: 469]
                        }
                        [cite_start]return []; [cite: 470]
                    [cite_start]}); [cite: 470]
                }
            }
        [cite_start]}); [cite: 471]
    </script>
</body>
</html>
